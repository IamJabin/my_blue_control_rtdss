/*****************************************************************************
 * Copyright (c) 2019, Nations Technologies Inc.
 *
 * All rights reserved.
 * ****************************************************************************
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer below.
 *
 * Nations' name may not be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY NATIONS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * DISCLAIMED. IN NO EVENT SHALL NATIONS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ****************************************************************************/

/**
 * @file n32wb03x_qflash.c
 * @author Nations Firmware Team
 * @version v1.0.4
 *
 * @copyright Copyright (c) 2019, Nations Technologies Inc. All rights reserved.
 */
#include "n32wb03x_qflash.h"
#include <string.h>
/** @addtogroup n32wb03x_StdPeriph_Driver
 * @{
 */

/** @addtogroup QFLASH
 * @brief QFLASH driver modules
 * @{
 */
 

/** @addtogroup QFLASH_Private_TypesDefinitions
 * @{
 */

/**
 * @}
 */

/** @addtogroup QFLASH_Private_Defines
 * @{
 */

#define GLOBAL_INT_DISABLE()        \
uint32_t ui32IntStatus = 0;         \
do{                                 \
    ui32IntStatus = __get_PRIMASK();\
    __set_PRIMASK(1);               \
}while(0)

#define GLOBAL_INT_RESTORE()     \
do{                              \
    __set_PRIMASK(ui32IntStatus);\
}while(0)

/**
 * @}
 */

/** @addtogroup QFLASH_Private_Macros
 * @{
 */

/**
 * @}
 */

/** @addtogroup QFLASH_Private_Variables
 * @{
 */
static uint32_t ram_qflash_cmd[0x324/4+1];
const  uint8_t const_qflash_cmd[0x324] = {
0x01,0x38,0xfd,0xd1,0x70,0x47,0x00,0x00,0xf0,0xb4,0x03,0x24,0xa4,0x06,0x23,0x6a,
0x5b,0x08,0x5b,0x00,0x23,0x62,0x23,0x6a,0x02,0x25,0x2b,0x43,0x23,0x62,0x23,0x6a,
0x9b,0x07,0xfc,0xd4,0xff,0x23,0x01,0x33,0xa3,0x62,0x65,0x69,0xde,0x1d,0xb5,0x43,
0x65,0x61,0x65,0x69,0x1e,0x1d,0x35,0x43,0x65,0x61,0x00,0x02,0x6b,0x30,0x60,0x60,
0x08,0x20,0xa0,0x60,0xe2,0x60,0x01,0x26,0x26,0x61,0xa0,0x6a,0xc0,0x05,0xfc,0xd5,
0xa3,0x62,0x00,0x23,0xd2,0x1c,0x90,0x08,0x0e,0xd0,0x95,0x08,0x0f,0x48,0x00,0x68,
0x9a,0x00,0x88,0x54,0x07,0x0a,0x52,0x18,0x57,0x70,0x07,0x0c,0x00,0x0e,0x97,0x70,
0x5b,0x1c,0xd0,0x70,0x9d,0x42,0xf1,0xd8,0x60,0x69,0xff,0x21,0x08,0x31,0x88,0x43,
0x60,0x61,0x60,0x69,0x30,0x43,0x60,0x61,0x20,0x6a,0x80,0x08,0x80,0x00,0x20,0x62,
0x20,0x6a,0x30,0x43,0x20,0x62,0xf0,0xbc,0x00,0x20,0x70,0x47,0x80,0x00,0x00,0x0c,
0xf8,0xb5,0x06,0x46,0x01,0x20,0x00,0x25,0xc0,0x04,0x86,0x42,0x01,0xd9,0x05,0x20,
0xf8,0xbd,0x03,0x24,0xa4,0x06,0x20,0x6a,0x40,0x08,0x40,0x00,0x20,0x62,0x20,0x6a,
0x02,0x21,0x08,0x43,0x20,0x62,0x20,0x6a,0x80,0x07,0xfc,0xd4,0xff,0x27,0x01,0x37,
0xa7,0x62,0x00,0xf0,0xbb,0xf8,0x00,0x28,0x01,0xd0,0x03,0x25,0x15,0xe0,0x06,0x20,
0x60,0x60,0x01,0x21,0x21,0x61,0xa0,0x6a,0xc0,0x05,0xfc,0xd5,0xa7,0x62,0x30,0x02,
0x20,0x30,0x60,0x60,0x21,0x61,0xa0,0x6a,0xc0,0x05,0xfc,0xd5,0xa7,0x62,0x0c,0x48,
0x00,0xf0,0xc8,0xf8,0x00,0x28,0x00,0xd1,0x02,0x25,0x60,0x69,0xff,0x21,0x08,0x31,
0x88,0x43,0x60,0x61,0x60,0x69,0x01,0x21,0x08,0x43,0x60,0x61,0x20,0x6a,0x80,0x08,
0x80,0x00,0x20,0x62,0x20,0x6a,0x08,0x43,0x20,0x62,0x28,0x46,0xf8,0xbd,0x00,0x00,
0xe6,0x96,0x01,0x00,0xf7,0xb5,0x06,0x46,0x01,0x20,0xc0,0x04,0x82,0xb0,0x15,0x46,
0x86,0x42,0x02,0xd9,0x05,0x20,0x05,0xb0,0xf0,0xbd,0x03,0x20,0x80,0x06,0x01,0x6a,
0x49,0x08,0x49,0x00,0x01,0x62,0x01,0x6a,0x02,0x22,0x11,0x43,0x01,0x62,0x01,0x6a,
0x89,0x07,0xfc,0xd4,0xff,0x21,0x01,0x31,0x81,0x62,0xf2,0xb2,0x8c,0x1a,0xa5,0x42,
0x00,0xd8,0xac,0xb2,0x03,0x98,0x00,0x90,0x00,0xf0,0x68,0xf8,0x00,0x28,0x40,0xd1,
0x06,0x21,0x48,0x06,0x41,0x60,0x01,0x21,0x01,0x61,0x81,0x6a,0xc9,0x05,0xfc,0xd5,
0xff,0x21,0x01,0x31,0x03,0x20,0x80,0x06,0x81,0x62,0x41,0x69,0xff,0x22,0x08,0x32,
0x91,0x43,0x41,0x61,0x41,0x69,0x04,0x22,0x11,0x43,0x41,0x61,0x31,0x02,0x32,0x31,
0x41,0x60,0xc4,0x60,0x00,0x22,0x00,0x2c,0x16,0xd9,0x00,0x98,0x87,0x18,0x3b,0x78,
0xf8,0x78,0x19,0x46,0x7b,0x78,0x00,0x06,0x1b,0x02,0x19,0x43,0xbb,0x78,0x1b,0x04,
0x19,0x43,0x01,0x43,0x08,0x02,0xf9,0x78,0x00,0x0a,0x09,0x06,0x08,0x43,0x19,0x49,
0x08,0x60,0x12,0x1d,0xa2,0x42,0xe8,0xd3,0x01,0x21,0x03,0x20,0x80,0x06,0x01,0x61,
0x81,0x6a,0xc9,0x05,0xfc,0xd5,0xff,0x21,0x01,0x31,0x81,0x62,0x12,0x48,0x00,0xf0,
0x49,0xf8,0xa5,0x42,0x09,0xd0,0x03,0x98,0x36,0x19,0x00,0x19,0x2d,0x1b,0xff,0x24,
0x01,0x34,0x03,0x90,0xa5,0x42,0xad,0xd8,0xab,0xe7,0x03,0x20,0x80,0x06,0x41,0x69,
0xff,0x22,0x08,0x32,0x91,0x43,0x41,0x61,0x41,0x69,0x01,0x22,0x11,0x43,0x41,0x61,
0x01,0x6a,0x89,0x08,0x89,0x00,0x01,0x62,0x01,0x6a,0x11,0x43,0x01,0x62,0x00,0x20,
0x05,0xb0,0xf0,0xbd,0x80,0x00,0x00,0x0c,0x1a,0x06,0x00,0x00,0x38,0xb4,0x01,0x25,
0x03,0x20,0x80,0x06,0x6a,0x46,0xc5,0x60,0x35,0x21,0x41,0x60,0x05,0x61,0x81,0x6a,
0xc9,0x05,0xfc,0xd5,0xff,0x24,0x01,0x34,0x84,0x62,0x81,0x69,0xc5,0x60,0xcb,0xb2,
0x05,0x21,0x41,0x60,0x05,0x61,0x81,0x6a,0xc9,0x05,0xfc,0xd5,0x84,0x62,0x80,0x69,
0x19,0x02,0xc0,0xb2,0x01,0x43,0x88,0xb2,0x11,0x80,0xc0,0x07,0x00,0xd0,0x01,0x20,
0x38,0xbc,0x70,0x47,0xf8,0xb4,0x00,0x21,0x01,0x25,0x03,0x22,0x92,0x06,0x6b,0x46,
0xd5,0x60,0x35,0x24,0x54,0x60,0x15,0x61,0x94,0x6a,0xe4,0x05,0xfc,0xd5,0xff,0x27,
0x01,0x37,0x97,0x62,0x94,0x69,0xd5,0x60,0xe4,0xb2,0x05,0x26,0x56,0x60,0x15,0x61,
0x96,0x6a,0xf6,0x05,0xfc,0xd5,0x97,0x62,0x96,0x69,0x24,0x02,0xf6,0xb2,0x34,0x43,
0x1c,0x80,0xe3,0x07,0x22,0xd0,0x81,0x42,0x02,0xd9,0xf8,0xbc,0x00,0x20,0x70,0x47,
0x03,0x22,0x92,0x06,0x6b,0x46,0xd5,0x60,0x35,0x24,0x54,0x60,0x15,0x61,0x49,0x1c,
0x94,0x6a,0xe4,0x05,0xfc,0xd5,0x97,0x62,0x94,0x69,0xd5,0x60,0xe4,0xb2,0x05,0x26,
0x56,0x60,0x15,0x61,0x96,0x6a,0xf6,0x05,0xfc,0xd5,0x97,0x62,0x92,0x69,0x24,0x02,
0xd2,0xb2,0x14,0x43,0xa2,0xb2,0x1c,0x80,0xd2,0x07,0xdc,0xd1,0xf8,0xbc,0x01,0x20,
0x70,0x47,0x00,0x00};

/**
 * @}
 */

/** @addtogroup QFLASH_Private_FunctionPrototypes
 * @{
 */
typedef ReturnMsg CMD_FLASH_SE_t( uint32_t flash_address) ;
typedef ReturnMsg CMD_FLASH_WRITE_t(uint32_t flash_address, uint8_t* p_data, uint32_t len);
typedef ReturnMsg CMD_FLASH_READ_t(uint32_t flash_address, uint8_t* p_data, uint32_t len);

ReturnMsg (*CMD_FLASH_SE)( uint32_t flash_address);
ReturnMsg (*CMD_FLASH_WRITE)(uint32_t addr, uint8_t* p_data, uint32_t len);
ReturnMsg (*CMD_FLASH_READ)(uint32_t addr, uint8_t* p_data, uint32_t len);

/**
 * @}
 */

/** @addtogroup QFLASH_Private_Functions
 * @{
 */

/**
 * @brief  Initialize Qflash.
 */
void Qflash_Init(void)
{
    //Init Qflash algorithm  
    CMD_FLASH_SE =      (CMD_FLASH_SE_t *)((uint8_t*)ram_qflash_cmd + 0xA1);   
    CMD_FLASH_WRITE =   (CMD_FLASH_WRITE_t *)((uint8_t*)ram_qflash_cmd + 0x135);  
    CMD_FLASH_READ =    (CMD_FLASH_READ_t *)((uint8_t*)ram_qflash_cmd + 0x09);  
    memcpy(ram_qflash_cmd,const_qflash_cmd,0x324);
}

/**
 * @brief Erase one sector in flash with ble schedule on.
 * @param[in] flash_address erase address.
 * @return none.
 */
uint32_t Qflash_Erase_Sector(uint32_t address)
{
    ReturnMsg error;
    GLOBAL_INT_DISABLE();
    address -= 0x01000000;
    assert_param(CMD_FLASH_SE != NULL);
    error = CMD_FLASH_SE(address);
    assert_param(error == FlashOperationSuccess);
    GLOBAL_INT_RESTORE();
    return error;
}

/**
 * @brief Write mutable length data to flash with ble schedule on.
 * @param[in] addr flash address.
 * @param[in] p_data data to write.
 * @param[in] len data len.
 * @return none.
 */
uint32_t Qflash_Write(uint32_t address, uint8_t* p_data, uint32_t len)
{
    ReturnMsg error;
    GLOBAL_INT_DISABLE();
    address -= 0x01000000;
    assert_param(CMD_FLASH_WRITE != NULL);
    error = CMD_FLASH_WRITE(address, p_data, len);
    assert_param(error == FlashOperationSuccess);
    GLOBAL_INT_RESTORE();
    return error;
}


/**
 * @brief Read mutable length data to ram.
 * @param[in] addr flash address.
 * @param[out] p_data data to read.
 * @param[in] len data len.
 * @return none.
 */
uint32_t Qflash_Read(uint32_t address, uint8_t* p_data, uint32_t len)
{
    
    ReturnMsg error;
    GLOBAL_INT_DISABLE();    
    address -= 0x01000000;
    assert_param(CMD_FLASH_READ != NULL);
    error = CMD_FLASH_READ(address, p_data, len);
    assert_param(error == FlashOperationSuccess);
    GLOBAL_INT_RESTORE();
    return error;
}




//Read function
typedef uint32_t (*trim_read_cmd_func_t)(uint32_t,uint8_t*,uint32_t);
extern const unsigned char  TRIM_READ_CMD_CODE[];
//Write function
typedef uint32_t (*trim_write_cmd_func_t)(uint32_t,uint8_t*,uint32_t);
#define TRIM_WRITE_CMD_CODE_LEN     0x200
#define TRIM_WRITE_CMD_CODE_CRC     0xb1e6
const unsigned char  TRIM_WRITE_CMD_CODE[] ={
0x40,0xba,0x70,0x47,0xc0,0xba,0x70,0x47,0x01,0x38,0xfd,0xd1,0x70,0x47,0x00,0x00,
0xf7,0xb5,0x03,0x26,0xb6,0x06,0x30,0x6a,0x82,0xb0,0x15,0x46,0x0f,0x46,0x40,0x08,
0x40,0x00,0x30,0x62,0x30,0x6a,0x02,0x21,0x08,0x43,0x30,0x62,0x30,0x6a,0x80,0x07,
0xfc,0xd4,0x66,0x20,0x70,0x60,0x01,0x24,0x34,0x61,0xb0,0x6a,0xc0,0x05,0xfc,0xd5,
0x99,0x20,0x70,0x60,0x34,0x61,0xb0,0x6a,0xc0,0x05,0xfc,0xd5,0xff,0x20,0x91,0x30,
0xff,0xf7,0xda,0xff,0xff,0x20,0x01,0x30,0xb0,0x62,0x00,0xf0,0x99,0xf8,0x00,0x28,
0x02,0xd0,0x03,0x20,0x05,0xb0,0xf0,0xbd,0xff,0x21,0x01,0x31,0xb1,0x62,0x06,0x20,
0x70,0x60,0x01,0x20,0x30,0x61,0xb0,0x6a,0xc0,0x05,0xfc,0xd5,0xff,0x20,0x01,0x30,
0xb0,0x62,0xb0,0x62,0x71,0x69,0xc0,0x1d,0x81,0x43,0x71,0x61,0x70,0x69,0x04,0x21,
0x08,0x43,0x70,0x61,0x02,0x98,0x00,0x02,0x42,0x30,0x70,0x60,0xf5,0x60,0x00,0x24,
0x00,0x2d,0x18,0xd9,0x3b,0x19,0x1a,0x78,0xd9,0x78,0x10,0x46,0x5a,0x78,0x09,0x06,
0x12,0x02,0x10,0x43,0x9a,0x78,0x12,0x04,0x10,0x43,0x08,0x43,0x00,0x02,0xd9,0x78,
0x00,0x0a,0x09,0x06,0x08,0x43,0x30,0x49,0x08,0x60,0x64,0x20,0xff,0xf7,0x9c,0xff,
0x24,0x1d,0xac,0x42,0xe6,0xd3,0x01,0x21,0x31,0x61,0xb0,0x6a,0xc0,0x05,0xfc,0xd5,
0xff,0x25,0x01,0x35,0xb5,0x62,0x29,0x4f,0x00,0x20,0x6a,0x46,0xf1,0x60,0x35,0x23,
0x73,0x60,0x31,0x61,0xb3,0x6a,0xdb,0x05,0xfc,0xd5,0xb5,0x62,0xb3,0x69,0x01,0x21,
0xdb,0xb2,0xf1,0x60,0x05,0x24,0x74,0x60,0x31,0x61,0x31,0x46,0x8e,0x6a,0xf6,0x05,
0xfc,0xd5,0x8d,0x62,0x8e,0x69,0x1b,0x02,0xf6,0xb2,0x33,0x43,0x13,0x80,0xda,0x07,
0x1e,0xd0,0xb8,0x42,0x01,0xd9,0x02,0x20,0x1b,0xe0,0x01,0x26,0x6a,0x46,0xce,0x60,
0x35,0x23,0x4b,0x60,0x0e,0x61,0x40,0x1c,0x8b,0x6a,0xdb,0x05,0xfc,0xd5,0x8d,0x62,
0x8b,0x69,0xce,0x60,0xdb,0xb2,0x4c,0x60,0x0e,0x61,0x8e,0x6a,0xf6,0x05,0xfc,0xd5,
0x8d,0x62,0x8e,0x69,0x1b,0x02,0xf6,0xb2,0x33,0x43,0x13,0x80,0xda,0x07,0xe0,0xd1,
0x00,0x20,0x8d,0x62,0x4a,0x69,0xff,0x23,0x08,0x33,0x9a,0x43,0x4a,0x61,0x4b,0x69,
0x01,0x22,0x13,0x43,0x4b,0x61,0x0b,0x6a,0x9b,0x08,0x9b,0x00,0x0b,0x62,0x0b,0x6a,
0x13,0x43,0x0b,0x62,0x05,0xb0,0xf0,0xbd,0x80,0x00,0x00,0x0c,0x1a,0x06,0x00,0x00,
0x38,0xb4,0x01,0x25,0x03,0x20,0x80,0x06,0x6a,0x46,0xc5,0x60,0x35,0x21,0x41,0x60,
0x05,0x61,0x81,0x6a,0xc9,0x05,0xfc,0xd5,0xff,0x24,0x01,0x34,0x84,0x62,0x81,0x69,
0xc5,0x60,0xcb,0xb2,0x05,0x21,0x41,0x60,0x05,0x61,0x81,0x6a,0xc9,0x05,0xfc,0xd5,
0x84,0x62,0x80,0x69,0x19,0x02,0xc0,0xb2,0x01,0x43,0x88,0xb2,0x11,0x80,0xc0,0x07,
0x00,0xd0,0x01,0x20,0x38,0xbc,0x70,0x47,0x03,0x20,0x80,0x06,0x41,0x69,0xff,0x22,
0x08,0x32,0x91,0x43,0x41,0x61,0x42,0x69,0x01,0x21,0x0a,0x43,0x42,0x61,0x02,0x6a,
0x92,0x08,0x92,0x00,0x02,0x62,0x02,0x6a,0x0a,0x43,0x02,0x62,0x70,0x47,0x00,0x00,
};

//Erase function
typedef uint32_t (*trim_erase_cmd_func_t)(uint32_t);
#define   TRIM_ERASE_CMD_CODE_LEN  0x180
#define   TRIM_ERASE_CMD_CODE_CRC  0x22
const unsigned char  TRIM_ERASE_CMD_CODE[] ={
0x40,0xba,0x70,0x47,0xc0,0xba,0x70,0x47,0x01,0x38,0xfd,0xd1,0x70,0x47,0x00,0x00,
0xf8,0xb5,0x03,0x26,0x07,0x46,0xb6,0x06,0x30,0x6a,0x40,0x08,0x40,0x00,0x30,0x62,
0x30,0x6a,0x02,0x21,0x08,0x43,0x30,0x62,0x30,0x6a,0x80,0x07,0xfc,0xd4,0x66,0x20,
0x70,0x60,0x01,0x24,0x34,0x61,0xb0,0x6a,0xc0,0x05,0xfc,0xd5,0x99,0x20,0x70,0x60,
0x34,0x61,0xb0,0x6a,0xc0,0x05,0xfc,0xd5,0xff,0x20,0x91,0x30,0xff,0xf7,0xdc,0xff,
0xff,0x25,0x01,0x35,0xb5,0x62,0xa8,0x03,0x87,0x42,0x01,0xd9,0x05,0x20,0xf8,0xbd,
0x68,0x46,0xf4,0x60,0x35,0x21,0x71,0x60,0x34,0x61,0xb1,0x6a,0xc9,0x05,0xfc,0xd5,
0xb5,0x62,0xb1,0x69,0xf4,0x60,0xca,0xb2,0x05,0x23,0x73,0x60,0x34,0x61,0xb1,0x6a,
0xc9,0x05,0xfc,0xd5,0xb5,0x62,0x11,0x02,0xb2,0x69,0xd2,0xb2,0x11,0x43,0x01,0x80,
0xc8,0x07,0xe5,0xd1,0x06,0x20,0x31,0x46,0x70,0x60,0x34,0x61,0x88,0x6a,0xc0,0x05,
0xfc,0xd5,0x8d,0x62,0x38,0x02,0x44,0x30,0x48,0x60,0x0c,0x61,0x88,0x6a,0xc0,0x05,
0xfc,0xd5,0x8d,0x62,0x27,0x4f,0x00,0x20,0x6a,0x46,0xcc,0x60,0x35,0x23,0x4b,0x60,
0x0c,0x61,0x8b,0x6a,0xdb,0x05,0xfc,0xd5,0x8d,0x62,0x8b,0x69,0x01,0x26,0xdb,0xb2,
0xce,0x60,0x05,0x24,0x4c,0x60,0x0e,0x61,0x8e,0x6a,0xf6,0x05,0xfc,0xd5,0x8d,0x62,
0x8e,0x69,0x1b,0x02,0xf6,0xb2,0x33,0x43,0x13,0x80,0xda,0x07,0x1e,0xd0,0xb8,0x42,
0x01,0xd9,0x02,0x20,0x1b,0xe0,0x01,0x26,0x6a,0x46,0xce,0x60,0x35,0x23,0x4b,0x60,
0x0e,0x61,0x40,0x1c,0x8b,0x6a,0xdb,0x05,0xfc,0xd5,0x8d,0x62,0x8b,0x69,0xce,0x60,
0xdb,0xb2,0x4c,0x60,0x0e,0x61,0x8e,0x6a,0xf6,0x05,0xfc,0xd5,0x8d,0x62,0x8e,0x69,
0x1b,0x02,0xf6,0xb2,0x33,0x43,0x13,0x80,0xda,0x07,0xe0,0xd1,0x00,0x20,0x8d,0x62,
0x4a,0x69,0xff,0x23,0x08,0x33,0x9a,0x43,0x4a,0x61,0x4a,0x69,0x01,0x23,0x1a,0x43,
0x4a,0x61,0x0a,0x6a,0x92,0x08,0x92,0x00,0x0a,0x62,0x0a,0x6a,0x1a,0x43,0x0a,0x62,
0xf8,0xbd,0x00,0x00,0xe6,0x96,0x01,0x00,0x03,0x20,0x80,0x06,0x41,0x69,0xff,0x22,
0x08,0x32,0x91,0x43,0x41,0x61,0x42,0x69,0x01,0x21,0x0a,0x43,0x42,0x61,0x02,0x6a,
0x92,0x08,0x92,0x00,0x02,0x62,0x02,0x6a,0x0a,0x43,0x02,0x62,0x70,0x47,0x00,0x00,
};

//Lock function
typedef uint32_t (*trim_lock_cmd_func_t)(uint32_t);
#define    OTP_LOCK_array_len  0x140
const unsigned char   OTP_LOCK[] ={
0x40,0xba,0x70,0x47,0xc0,0xba,0x70,0x47,0x30,0xb4,0x01,0x25,0x03,0x21,0x89,0x06,
0xcd,0x60,0x35,0x22,0x4a,0x60,0x0d,0x61,0x8a,0x6a,0xd2,0x05,0xfc,0xd5,0xff,0x24,
0x01,0x34,0x8c,0x62,0x8a,0x69,0xcd,0x60,0xd3,0xb2,0x05,0x22,0x4a,0x60,0x0d,0x61,
0x8a,0x6a,0xd2,0x05,0xfc,0xd5,0x8c,0x62,0x89,0x69,0x1a,0x02,0xc9,0xb2,0x0a,0x43,
0x02,0x80,0x30,0xbc,0x00,0x20,0x70,0x47,0xf0,0xb5,0x03,0x24,0x06,0x46,0xa4,0x06,
0x20,0x6a,0x83,0xb0,0x40,0x08,0x40,0x00,0x20,0x62,0x20,0x6a,0x02,0x21,0x08,0x43,
0x20,0x62,0x20,0x6a,0x80,0x07,0xfc,0xd4,0xff,0x25,0x01,0x35,0xa5,0x62,0x01,0x27,
0x01,0xa8,0xff,0xf7,0xc9,0xff,0x68,0x46,0x80,0x88,0xc0,0x07,0xf8,0xd1,0xa5,0x62,
0x69,0x46,0x08,0x80,0x68,0x46,0xff,0xf7,0xbf,0xff,0xa5,0x62,0x69,0x46,0x08,0x88,
0x31,0x0b,0x3e,0x46,0x0a,0x31,0x8e,0x40,0x06,0x43,0x01,0xa8,0xff,0xf7,0xb4,0xff,
0x68,0x46,0x80,0x88,0xc0,0x07,0xf8,0xd1,0xa5,0x62,0x06,0x20,0x60,0x60,0x27,0x61,
0xa0,0x6a,0xc0,0x05,0xfc,0xd5,0xa5,0x62,0x60,0x69,0xff,0x21,0x08,0x31,0x88,0x43,
0x60,0x61,0x60,0x69,0x04,0x21,0x08,0x43,0x60,0x61,0x67,0x60,0x02,0x20,0xe0,0x60,
0x19,0x48,0x06,0x60,0x27,0x61,0xa0,0x6a,0xc0,0x05,0xfc,0xd5,0xff,0x20,0x01,0x30,
0xa0,0x62,0x16,0x4e,0x00,0x25,0x01,0xa8,0xff,0xf7,0x8e,0xff,0x68,0x46,0x80,0x88,
0xc0,0x07,0x02,0xd1,0x0c,0xe0,0x02,0x20,0x0b,0xe0,0x01,0xa8,0x6d,0x1c,0xff,0xf7,
0x83,0xff,0x68,0x46,0x80,0x88,0xc0,0x07,0x02,0xd0,0xb5,0x42,0xf5,0xd9,0xf2,0xe7,
0x00,0x20,0xff,0x21,0x01,0x31,0xa1,0x62,0x62,0x69,0xc9,0x1d,0x8a,0x43,0x62,0x61,
0x61,0x69,0x39,0x43,0x61,0x61,0x21,0x6a,0x89,0x08,0x89,0x00,0x21,0x62,0x21,0x6a,
0x39,0x43,0x21,0x62,0x03,0xb0,0xf0,0xbd,0x80,0x00,0x00,0x0c,0x58,0x14,0x00,0x00,
};



#define TRIM_READ_CMD_CODE_LEN  0x140

/**
 * @brief Read mutable length OTP data to ram.
 * @param[in] address OTP address.
 * @param[out] p_data data to read.
 * @param[in] byte_length data len.
 * @return none.
 */
uint32_t OTPTrim_Read(uint32_t address, uint8_t* p_data, uint32_t byte_length)
{  
    uint32_t error=FlashAddressInvalid;
    GLOBAL_INT_DISABLE();        
    if(OTP_ADDRESS_CHECK(address))
    {
        uint32_t ramcode[TRIM_READ_CMD_CODE_LEN/4 +1 ];
        trim_read_cmd_func_t trim_read_cmd_func = (trim_read_cmd_func_t)((uint8_t*)&ramcode[0] + 0x11);
        memcpy((void*)ramcode,(const void*)TRIM_READ_CMD_CODE,TRIM_READ_CMD_CODE_LEN);
        error = (*trim_read_cmd_func)(address, p_data, byte_length);
    }
    GLOBAL_INT_RESTORE();
    return error;
}

/**
 * @brief Write mutable length data to OTP.
 * @param[in] address OTP address.
 * @param[out] p_data data to write.
 * @param[in] byte_length data len.
 * @return none.
 */
uint32_t OTPTrim_Write(uint32_t address, uint8_t* p_data, uint32_t byte_length)
{
    uint32_t error=FlashAddressInvalid;
    uint32_t write_len ;
    GLOBAL_INT_DISABLE();
    if(OTP_ADDRESS_CHECK(address))
    {
        uint32_t ramcode[TRIM_WRITE_CMD_CODE_LEN/4 +1 ];
        trim_write_cmd_func_t trim_write_cmd_func = (trim_write_cmd_func_t)((uint8_t*)&ramcode[0] + 0x11);
        memcpy((void*)ramcode,(const void*)TRIM_WRITE_CMD_CODE,TRIM_WRITE_CMD_CODE_LEN);
        if (byte_length <= 256) 
        {
            write_len = byte_length;
        }
        else 
        {
            write_len = 256;
        }
        error = (*trim_write_cmd_func)(address, p_data, write_len);
        if(error != FlashOperationSuccess)
        {
            return error;
        }
        if(byte_length > 256)
        {
            error = (*trim_write_cmd_func)(address+256, &p_data[256], byte_length-256);
        }
    }
    GLOBAL_INT_RESTORE();    
    return error;
}

/**
 * @brief Erase one of OTP sector.
 * @param[in] address To erase address.
 * @return none.
 */
uint32_t OTPTrim_Erase(uint32_t address)
{
    uint32_t error=FlashAddressInvalid;
    GLOBAL_INT_DISABLE();   
    if(OTP_ADDRESS_CHECK(address))
    {
        uint32_t ramcode[TRIM_ERASE_CMD_CODE_LEN/4 +1 ];
        trim_erase_cmd_func_t trim_erase_cmd_func = (trim_erase_cmd_func_t)((uint8_t*)&ramcode[0] + 0x11);
        memcpy((void*)ramcode,(const void*)TRIM_ERASE_CMD_CODE,TRIM_ERASE_CMD_CODE_LEN);
        error = (*trim_erase_cmd_func)(address);
    }
    GLOBAL_INT_RESTORE();
    return error;
}

/**
 * @brief Lock one of OTP sector.
 * @param[in] address erase address.
 * @return none.
 */
uint32_t OTPTrim_Lock(uint32_t address)
{
    uint32_t error=FlashAddressInvalid;
    GLOBAL_INT_DISABLE();   
    if(OTP_ADDRESS_CHECK(address))
    {
        uint32_t ramcode[OTP_LOCK_array_len/4 +1 ];
        trim_lock_cmd_func_t trim_lock_cmd_func = (trim_lock_cmd_func_t)((uint8_t*)&ramcode[0]+0x49);
        memcpy((void*)ramcode,(const void*)OTP_LOCK,OTP_LOCK_array_len);
        error = (*trim_lock_cmd_func)(address);
    }
    GLOBAL_INT_RESTORE();
    return error;
}
/**
 * @}
 */ 

/**
 * @}
 */ 

/**
 * @}
 */ 



